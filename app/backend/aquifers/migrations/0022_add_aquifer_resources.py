# Generated by Django 2.1.7 on 2019-03-07 21:31
import os
import sys

from django.db import migrations, models
import django.db.models.deletion
from django.conf import settings

from aquifers.models import AquiferResource, Aquifer
from gwells.codes import CodeFixture


TESTING = len(sys.argv) > 1 and sys.argv[1] == 'test'


def aquifer_resources():
    fixture = '0010_aquifer_resources.json'
    fixture_path = os.path.join(os.path.dirname(
        os.path.realpath(__file__)), fixture)
    return CodeFixture(fixture_path)


# def generate_aquifer_resource_reverse(apps, schema_editor):
#     AquiferResource.objects.filter(
#         url='https://onlinelibrary.wiley.com/doi/abs/10.1002/hyp.7724').delete()


# def generate_aquifer_resource(apps, schema_editor):
#     for aquifer in Aquifer.objects.all():
#         AquiferResource.create(
#             aquifer=aqufier,
#             section_id='I',
#             url='https://onlinelibrary.wiley.com/doi/abs/10.1002/hyp.7724',
#             name='Evaluating the use of a gridded climate surface for modelling groundwater recharge in a semi-arid region',
#         )


class Migration(migrations.Migration):

    dependencies = [
        ('aquifers', '0021_auto_20190502_0551'),
    ]

    operations = []

    # TODO: we have a large set of production aquifer resources we're attempting to import mid-migrations.
    # This methodology presents a dilemma because these resources only work if the entire production aquifer dataset is present,
    # not the case on dev or test. What should we do?
    if not settings.DEBUG and not TESTING:
        operations.append(
            migrations.RunPython(
                aquifer_resources().load_fixture,
                reverse_code=aquifer_resources().unload_fixture
            )
        )
